-- ====================================== 8. TRIGGER ======================================
-- 트리거 : 방아쇠, 연쇄반응, ...
-- 특정이벤트나 DDL, DML문장이 실행되었을 때
-- 자동적으로 어떤 일련의 동작(Operation), 처리가 수행되도록 하는 데이터베이스 객체의 하나임.
-- 예시 ) 회원 탈퇴가 이루어질 경우 회원 탈퇴 테이블에 대한 기존 회원정보가 자동으로 입력되도록 설정
-- or 데이터 변경이 있을 때, 조작한 데이터에 대한 로그이력을 남기는 경우
-- 사용방법
-- CREATE OR REPLACE TRIGGER 트리거명
-- BEFORE (OR AFTER)
-- DELETE (OR UPDATE OR INSERT) ON 테이블명
-- [FOR EACH ROW]
-- BEGIN
--      (실행문)
-- END;
-- /
-- 예제. 사원 테이블에 새로운 데이터가 들어오면 신입사워 입사하였습니다. 를 출력하기
SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE PROC_ADD_ONE_EMP
(
  V_ENAME IN EMPLOYEE.EMP_NAME%TYPE,
  V_PERSONNO IN EMPLOYEE.EMP_NO%TYPE,
  V_MOBILE IN EMPLOYEE.PHONE%TYPE,
  V_JCODE IN EMPLOYEE.JOB_CODE%TYPE,
  V_SALLEVEL IN EMPLOYEE.SAL_LEVEL%TYPE
)
IS
  LAST_NUM VARCHAR2(10);
BEGIN
    SELECT MAX(EMP_ID)
    INTO LAST_NUM
    FROM EMPLOYEE;
    
    INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, PHONE, JOB_CODE, SAL_LEVEL)
    VALUES(LAST_NUM+1, V_ENAME, V_PERSONNO, V_MOBILE, V_JCODE, V_SALLEVEL);
    COMMIT;
END;
/
EXEC PROC_ADD_ONE_EMP('백일용자','990621-1160423','01088373332','J5','S5');
SELECT * FROM EMPLOYEE;


CREATE OR REPLACE TRIGGER TRG_EMP_NEW
AFTER
INSERT ON EMPLOYEE
FOR EACH ROW
BEGIN
 DBMS_OUTPUT.PUT_LINE('신입사원이 입사했습니다.');
END;
/

SELECT * FROM USER_TRIGGERS;

-- 예제2. EMPLOYEE 테이블에 급여 정보가 변경되면 전후 정보를 화면에 출력하는 트리거를 생성하시오.
SELECT * FROM EMP_DUPLICATE;
DELETE FROM EMP_DUPLICATE WHERE EMP_NAME LIKE '%용자%';
COMMIT;
ROLLBACK;
-- 트리거 확인하기 (커밋후확인가능)
UPDATE EMP_DUPLICATE
SET SALARY = SALARY*2
WHERE EMP_ID = '205';
-- COMMIT 후 확인가능
COMMIT;

CREATE OR REPLACE TRIGGER TRG_EMP_SALINFO
AFTER
UPDATE ON EMP_DUPLICATE
FOR EACH ROW
BEGIN
  DBMS_OUTPUT.PUT_LINE('변경 전: '||:OLD.SALARY);
  DBMS_OUTPUT.PUT_LINE('변경 후: '||:NEW.SALARY);
END;
/

DROP TABLE EMP_DUPLICATE;
CREATE TABLE EMP_DUPLICATE
AS SELECT * FROM EMPLOYEE;

-- ======================================== 의사레코드 OLD, NEW ========================================
-- FOR EACH ROW를 사용
-- 1. INSERT : OLD -> NULL, NEW -> 변경 후의 레코드
-- 2. UPDATE : OLD -> 변경 전의 레코드, NEW -> 변경 후의 레코드
-- 3. DELETE : OLD -> 변경 전의 레코드, NEW -> NULL

-- @실습예제1
-- 1. 제품 PRODUCT 테이블은 숫자로 된 PCODE컬럼이 있고 PRIMARY KEY로 지정, 문자열 크기 30인
-- PNAME인 컬럼, 문자열 크기 30인 BRAND컬럼, 숫자로 된 PRICE 컬럼, 숫자로 되어 있고 기본값이 0인 STOCK컬럼이
-- 있음.
CREATE TABLE PRODUCT -- 부모테이블
(
    PCODE NUMBER PRIMARY KEY,
    PNAME VARCHAR2(30),
    BRAND VARCHAR2(30),
    PRICE NUMBER,
    STOCK NUMBER DEFAULT 0
);
-- 2. 제품 입출고 PRODUCT_IO 테이블은 숫자로 된 IOCODE 컬럼이 있고 PRIMARY KEY로 지정,
-- 숫자로 된 PCODE컬럼, 날짜로 된 PDATE 컬럼, 숫자로된 AMOUNT컬럼, 문자열 크기가 10인
-- STATUS컬럼이 있음. STATUS컬럼은 입고 또는 출고만 입력가능함.
-- PCODE는 PRODUCT 테이블의 PCODE를 참조하여 외래키로 설정되어 있음.
CREATE TABLE PRODUCT_IO --자식테이블
(
    IOCODE NUMBER PRIMARY KEY,
    PCODE NUMBER CONSTRAINT FK_PRODUCT_IO REFERENCES PRODUCT(PCODE),
    PDATE DATE,
    AMOUNT NUMBER,
    STATUS VARCHAR2(10) CHECK(STATUS IN('입고','출고'))
);
-- 3. 시퀀스는 SEQ_PRODUCT_PCODE, SEQ_PRODUCTIO_IOCODE라는 이름으로 기본값으로 설정되어있음.
CREATE SEQUENCE SEQ_PRODUCT_PCODE
START WITH 1
INCREMENT BY 1
NOCYCLE
NOCACHE;
CREATE SEQUENCE SEQ_PRODUCTIO_IOCODE;
SELECT * FROM USER_SEQUENCES;
-- 4. 트리거의 이름은 TRG_PRODUCT 이고 PRODUCT_IO 테이블에 입고를 하면 PRODUCT 테이블에
-- STOCK 컬럼에 값을 추가하고 PRODUCT_IO 테이블에 출고를 하면 STOCK 컬럼에 값을 빼주는 역할을 함.
CREATE OR REPLACE TRIGGER TRG_PRODUCT
AFTER
INSERT ON PRODUCT_IO
FOR EACH ROW
BEGIN
-- INSERT INTO PRODUCT_IO 
-- VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL,1,SYSDATE, 10, '입고');
    IF :NEW.STATUS = '입고'
    THEN
        UPDATE PRODUCT
        SET STOCK = STOCK + :NEW.AMOUNT
        WHERE PCODE = :NEW.PCODE;
        --DBMS_OUTPUT.PUT_LINE('제품이 입고 되었습니다. 수량 : '||:NEW.AMOUNT);
    ELSIF :NEW.STATUS = '출고'
    THEN
        UPDATE PRODUCT
        SET STOCK = STOCK - :NEW.AMOUNT
        WHERE PCODE = :NEW.PCODE;
        --DBMS_OUTPUT.PUT_LINE('제품이 출고 되었습니다. 수량 : '||:NEW.AMOUNT);
    END IF;
END;
/

-- TEST해보기
-- 제품 테이블 정보 입력
DESC PRODUCT;
INSERT INTO PRODUCT VALUES(SEQ_PRODUCT_PCODE.NEXTVAL, '갤럭시폰', '삼성', 1000000, DEFAULT);
INSERT INTO PRODUCT VALUES(SEQ_PRODUCT_PCODE.NEXTVAL, '아이폰', '애플', 1200000, DEFAULT);
INSERT INTO PRODUCT VALUES(SEQ_PRODUCT_PCODE.NEXTVAL, '대륙폰', '샤오미', 200000, DEFAULT);
SELECT * FROM PRODUCT;
COMMIT;
-- 제품 출고 테이블 INSERT
INSERT INTO PRODUCT_IO 
VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL,1,SYSDATE, 10, '입고');
INSERT INTO PRODUCT_IO 
VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL,1,SYSDATE, 5, '출고');
DESC PRODUCT_IO;
CREATE OR REPLACE PROCEDURE PROC_PRODUCT_IO
(
    V_PCODE IN PRODUCT_IO.PCODE%TYPE,
    V_AMOUT IN PRODUCT_IO.AMOUNT%TYPE,
    V_STATUS IN PRODUCT_IO.STATUS%TYPE
)
IS
    V_STOCK PRODUCT.STOCK%TYPE;
    V_PNAME PRODUCT.PNAME%TYPE;
    V_BRAND PRODUCT.BRAND%TYPE;
BEGIN
    INSERT INTO PRODUCT_IO 
    VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL,V_PCODE,SYSDATE, V_AMOUT, V_STATUS);
    COMMIT;
    SELECT PNAME, BRAND, STOCK
    INTO V_PNAME, V_BRAND, V_STOCK
    FROM PRODUCT
    WHERE PCODE = V_PCODE;
    DBMS_OUTPUT.PUT_LINE('제품이 '||V_STATUS||' 되었습니다. 수량 : '||V_AMOUT);
    DBMS_OUTPUT.PUT_LINE('브랜드명 : '||V_BRAND||', 제품명 : '||V_PNAME);
    DBMS_OUTPUT.PUT_LINE('현재 재고량은 '||V_STOCK||'입니다.');    
END;
/
EXECUTE PROC_PRODUCT_IO(1, 10,'입고');
EXECUTE PROC_PRODUCT_IO(1, 7,'출고');
COMMIT;
SELECT * FROM PRODUCT;
-- 제약조건 비활성화
-- PCODE가 외래키이기 때문에 PRODUCT 테이블의 PCODE와 같은 데이터만 들어갈 수 있음.
-- PRODUCT테이블에는 아무 데이터도 없기 때문에 오류 발생
-- parent key not found : 부모에는 1이라고 하는 데이터가 없어서 INSERT 불가능
ALTER TABLE PRODUCT_IO DISABLE CONSTRAINT FK_PRODUCT_IO;
ALTER TABLE PRODUCT_IO ENABLE CONSTRAINT FK_PRODUCT_IO;

SELECT * FROM PRODUCT_IO;
DELETE FROM PRODUCT_IO;
COMMIT;

-- 다지우고 아무것도 없다했을때 확인순서
-- 1. PRODUCT 테이블 생성
-- 2. PRODUCT_TO 테이블 생성
-- 3. 각각의 시퀀스 생성
-- 4. TRG_PRODUCT 트리거 생성
-- 5. PRODUCT 테이블에 데이터 삽입(갤럭시폰, 아이폰, 대륙폰) 후 COMMIT
-- 6. PROC_PRODUCT_IO 프로시져 생성후 프로시저 실행해서 메시지 확인


--DROP TABLE PRODUCT;
--DROP TABLE PRODUCT_IO;
--DROP SEQEUENCE SEQ_PRODUCTIO_IOCODE;

