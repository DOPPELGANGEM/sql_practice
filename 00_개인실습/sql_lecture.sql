-- ============ 데이터베이스란? ============
-- 데이터베이스 : 데이터를 저장하는 공간
-- SQL : 중요하고도 방대한 데이터를 다루는데 사용되는 언어 데이터를 꺼내고 수정하고 삭제하기 위해서 SQL 사용

-- ============ 테이블이란? ============
-- 데이터베이스 안에 데이터를 저장을 할때는 테이블형태로 저장한다.
-- 그리고 그 테이블은 컬럼과 로우로 이루어진다.

-- ============ CREATE ============
-- 텍스트 유형의 데이터를 담을 계획이면 VARCHAR 타입으로 컬럼을 만듬
-- 숫자유형의 데이터를 담을 계획이면 NUMBER 타입
-- 날짜 유형의 데이터를 담을 계획이면 DATE 타입으로 컬럼을 만들어준다.
-- * 오라클에서는 VARCHAR 타입을 VARCHAR2로 정의를 해줌 *

CREATE TABLE NETFLIX(
  VIDEO_NAME VARCHAR2(50),
  CATEGORY VARCHAR2(30),
  VIEW_CNT NUMBER(7),
  REG_DATE DATE
);

SELECT * FROM NETFLIX;

-- ============ ALTER ============
-- 기존에 생성해 놓았던 테이블을 변경하고 싶을 때 사용하는 명령어
-- ADD COLUMN으로 컬럼을 추가할 수도 있고 DROP COLUMN으로 컬럼을 삭제할 수가 있고
-- MODIFY COLUMN으로 컬럼을 변경할수도있다.
SELECT * FROM NETFLIX n;

ALTER TABLE NETFLIX ADD (CAST_MEMBER VARCHAR2(20));
ALTER TABLE NETFLIX MODIFY (CAST_MEMBER VARCHAR2(50));
ALTER TABLE NETFLIX MODIFY (CAST_MEMBER NUMBER(2)); -- CAST_MEMBER를 NUMBER타입으로 변경
ALTER TABLE NETFLIX DROP (CAST_MEMBER);

-- ============ DROP / TRUNCATE ============
-- DROP TABLE : 테이블을 삭제한다.
-- TRUNCATE TABLE : 테이블을 초기화한다. (테이블은 그대로 남아 있지만 그 안에 저장되어 있던 데이터가 모두 삭제된다)
-- 참고로 DROP이나 TRUNCATE로 삭제된 테이블과 데이터는 다시 복구할수없다!
CREATE TABLE CODELION(
  COL1 VARCHAR(3),
  COL2 VARCHAR(3)
);
SELECT * FROM CODELION;

INSERT INTO CODELION VALUES('AAA','BBB');
INSERT INTO CODELION VALUES('CCC','DDD');
COMMIT;

DROP TABLE CODELION;
TRUNCATE TABLE CODELION;

-- ============ INSERT ============
-- 테이블에 새로운 데이터를 삽입하는 쿼리이다.
-- INSERT query 수행시 데이터가 한 ROW씩 테이블에 입력이된다.
SELECT * FROM NETFLIX n;
INSERT INTO NETFLIX VALUES('나의 아저씨','드라마',50,SYSDATE);
COMMIT;
INSERT INTO NETFLIX (VIDEO_NAME, VIEW_CNT) VALUES ('시그널',42);
ROLLBACK; -- 내가 INSERT 햇던 작업을 취소하는 행위

INSERT INTO NETFLIX VALUES('응답하라 1988', '드라마', 35, SYSDATE-30);
INSERT INTO NETFLIX VALUES('이태원클라쓰','드라마',30, SYSDATE-40);
INSERT INTO NETFLIX VALUES('미스터션사인','드라마',22, SYSDATE-300);
DELETE FROM NETFLIX WHERE VIDEO_NAME = '응답하라 1988';


-- ============ UPDATE ============
-- 데이터를 변경한다.
-- UPDATE를 사용할 때 주의할점은 WHERE 조건절을 빼먹었을 때 모든 데이터가 변경이 돼 버리기때문에 주의 WHERE 조건 잘작성하기
SELECT * FROM NETFLIX n;

UPDATE NETFLIX SET VIEW_CNT = 70 WHERE VIDEO_NAME = '나의 아저씨';
COMMIT;
ROLLBACK;

UPDATE NETFLIX SET CATEGORY = '드라마',REG_DATE = TO_DATE('20210101','YYYYMMDD') WHERE VIDEO_NAME = '시그널';

-- ============ DELETE ============
-- 테이블에 존재하는 데이터를 삭제하는 query
-- TRUNCATE와 유사하지만 TRUNCATE가 테이블의 모든 데이터를 삭제하는 역할을 한다면 DELETE는 내가원하는 데이터만 골라서 삭제할 수가 있다.
-- TRUNCATE는 한번 실행하면 되돌릴 수 없지만 DELETE는 ROLLBACK을 이용하여 되돌릴 수가 있다.
-- 모든 데이터를 삭제하는 경우라면 DELETE보다 TRUNCATE가 빠르다.
SELECT * FROM NETFLIX n;

DELETE FROM NETFLIX n WHERE VIDEO_NAME = '미스터션사인';
COMMIT;

DELETE FROM NETFLIX n WHERE CATEGORY = '드라마' AND VIEW_CNT < 35;
ROLLBACK;
DELETE FROM NETFLIX WHERE VIDEO_NAME IN ('시그널','나의 아저씨');
DELETE FROM NETFLIX n;

-- ============ SELECT ============
SELECT * FROM NETFLIX n;

SELECT * FROM NETFLIX n WHERE VIDEO_NAME = '나의 아저씨';
SELECT * FROM NETFLIX n WHERE VIDEO_NAME <> '나의 아저씨';
SELECT * FROM NETFLIX n WHERE VIEW_CNT = 50;
SELECT * FROM NETFLIX n WHERE VIEW_CNT <> 50;
SELECT * FROM NETFLIX n WHERE REG_DATE > SYSDATE-30; -- 최근 한달 동안인 데이터를 출력하고싶다
SELECT * FROM NETFLIX n WHERE REG_DATE < SYSDATE-30; -- 한달 전에 등록된 데이터
SELECT CATEGORY FROM NETFLIX n;
SELECT DISTINCT CATEGORY FROM NETFLIX n; -- 중복되는것은 하나로만 보고싶다 -> DISTINCT

-- ============ WHERE (1),(2) ============
-- 쿼리문에 조건을 부여한다.
SELECT * FROM NETFLIX;

--테이블 값 insert
INSERT INTO NETFLIX VALUES ('진격의 거인','애니메이션', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('도라에몽','애니메이션', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('천공의 성 라퓨타','애니메이션', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('귀를 기울이면','애니메이션', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('모노노케 히메','애니메이션', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('하트시그널','예능', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('연애의 참견','예능', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('효리네 민박','예능', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('미스트롯','예능', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('아는 형님','예능', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('리틀 포레스트','영화', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('건축학개론','영화', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('인터스텔라','영화', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('광해','영화', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('어바웃타임','영화', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('우리의 지구','다큐', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('인사이드 빌게이츠','다큐', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('길 위의 셰프들','다큐', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('죽어도 선덜랜드','다큐', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
INSERT INTO NETFLIX VALUES ('별나라 동물들','다큐', ROUND(DBMS_RANDOM.VALUE(0, 100)), SYSDATE-ROUND(DBMS_RANDOM.VALUE(0, 100)));
COMMIT;

SELECT * FROM NETFLIX WHERE CATEGORY = '애니메이션';
SELECT * FROM NETFLIX WHERE CATEGORY IN ('애니메이션','영화');
SELECT * FROM NETFLIX WHERE CATEGORY NOT IN ('애니메이션','영화');
SELECT * FROM NETFLIX WHERE VIEW_CNT < 70;
SELECT * FROM NETFLIX WHERE VIEW_CNT <= 70;
SELECT * FROM NETFLIX WHERE REG_DATE < TO_DATE('20210101','YYYYMMDD');

SELECT * FROM NETFLIX WHERE CATEGORY = '애니메이션' AND VIEW_CNT < 70;
SELECT * FROM NETFLIX WHERE CATEGORY = '애니메이션' AND REG_DATE < TO_DATE('20210101','YYYYMMDD');
SELECT * FROM NETFLIX WHERE CATEGORY = '애니메이션' OR VIEW_CNT < 70;
SELECT * FROM NETFLIX WHERE CATEGORY = '애니메이션' OR CATEGORY = '영화'; --IN으로 써도된다
SELECT * FROM NETFLIX WHERE VIDEO_NAME LIKE '미%'; -- 영상의 제목이 '미'로 시작되는 데이터를 조회를해라!
SELECT * FROM NETFLIX WHERE VIDEO_NAME LIKE '%인'; -- 영상의 제목이 '인'으로 끝나는 데이터를 조회를해라!
SELECT * FROM NETFLIX WHERE VIDEO_NAME LIKE '%의%'; -- 의라는 글자가 앞에있어도 되고 끝에있어도 된다.('의'가 들어가기만 하면 조회가됨)
SELECT * FROM NETFLIX WHERE VIEW_CNT >= 60 AND VIEW_CNT <= 70;
SELECT * FROM NETFLIX WHERE VIEW_CNT BETWEEN 60 AND 70;

-- ============ ORDER BY ============
-- 데이터를 정렬시킨다. 
-- 오름차순 : 큰거에서 작은거로(최솟값부터), 내림차순 :작은거에서 큰거로(최대값부터)
-- 숫자 1 2 3 4 5 (오름차순) , 5 4 3 2 1 (내림차순)
-- 알파벳 a b c d e (오름차순) , e d c b a (내림차순)
-- 한글 ㄱ ㄴ ㄷ ㄹ ㅁ (오름차순) , ㅁ ㄹ ㄷ ㄴ ㄱ (내림차순)
-- 날짜는 DESC 일때 최신순!!
SELECT * FROM NETFLIX ORDER BY REG_DATE; --ASC는 DEFAULT값
SELECT * FROM NETFLIX ORDER BY REG_DATE DESC;
SELECT * FROM NETFLIX ORDER BY VIDEO_NAME;
SELECT * FROM NETFLIX ORDER BY VIEW_CNT DESC;
SELECT * FROM NETFLIX ORDER BY CATEGORY, VIEW_CNT DESC;
SELECT * FROM NETFLIX ORDER BY CATEGORY DESC, VIEW_CNT DESC;

-- ============ GROUP BY ============
-- 데이터를 그룹으로 묶는다.
SELECT CATEGORY, COUNT(*) FROM NETFLIX GROUP BY CATEGORY;
SELECT CATEGORY, SUM(VIEW_CNT) FROM NETFLIX GROUP BY CATEGORY;
SELECT CATEGORY, MAX(VIEW_CNT) FROM NETFLIX GROUP BY CATEGORY;
SELECT CATEGORY, MAX(VIEW_CNT) FROM NETFLIX GROUP BY CATEGORY ORDER BY MAX(VIEW_CNT) DESC;
SELECT CATEGORY, MIN(VIEW_CNT) FROM NETFLIX GROUP BY CATEGORY;
SELECT CATEGORY, MAX(VIEW_CNT), MIN(VIEW_CNT) FROM NETFLIX GROUP BY CATEGORY;
SELECT CATEGORY, AVG(VIEW_CNT) FROM NETFLIX GROUP BY CATEGORY;


-- ============ INNER JOIN ============
-- JOIN : 여러개의 테이블을 연결한다.
-- 연결해주는 방식에따라 INNER JOIN, OUTER JOIN 으로 나누어진다.
-- INNER JOIN에서 가장 중요하게 기억해야 할 부분은 두 테이블에 공통적으로 존재하는 데이터여야지 출력이된다!
-- 그리고 JOIN의 관계는 1:1이 될 수도 있고 1:N이 될 수도 있고 N:1이 될 수도 있다.

CREATE TABLE NETFLIX_CAST (
	VIDEO_NAME		VARCHAR2(50),
	CAST_MEMBER		VARCHAR2(30),
	BIRTHDAY		DATE,
	GENDER			VARCHAR2(3)
);

INSERT INTO NETFLIX_CAST VALUES ('나의 아저씨','이지은',TO_DATE('19930516','YYYYMMDD'),'여');
INSERT INTO NETFLIX_CAST VALUES ('시그널','조진웅',TO_DATE('19760303','YYYYMMDD'),'남');
INSERT INTO NETFLIX_CAST VALUES ('효리네 민박','이효리',TO_DATE('19790510','YYYYMMDD'),'여');
INSERT INTO NETFLIX_CAST VALUES ('이태원 클라쓰','박서준',TO_DATE('19881216','YYYYMMDD'),'남');
INSERT INTO NETFLIX_CAST VALUES ('기생충','송강호',TO_DATE('19670117','YYYYMMDD'),'남');
INSERT INTO NETFLIX_CAST VALUES ('미생','임시완',TO_DATE('19881201','YYYYMMDD'),'남');
INSERT INTO NETFLIX_CAST VALUES ('승리호','김태리',TO_DATE('19900424','YYYYMMDD'),'여');

COMMIT;

SELECT * FROM NETFLIX_CAST;
-- JOIN을 할때는 컬럼앞에 이 컬럼이 어느 테이블에 속한 컬럼인지를 명시해 주기 위해서 테이블명.컬럼명 이런식으로 작성! (alias)
SELECT A.VIDEO_NAME, A.CATEGORY , B.CAST_MEMBER , B.BIRTHDAY
FROM NETFLIX A, NETFLIX_CAST B
WHERE A.VIDEO_NAME = B.VIDEO_NAME;

INSERT INTO NETFLIX_CAST VALUES('효리네 민박', '이상순', TO_DATE('19740825','YYYYMMDD'),'남');


-- ============ OUTER JOIN ============
-- LEFT OUTER JOIN , RIGHT OUTER JOIN, FULL OUTER JOIN
-- LEFT OUTER JOIN : LEFT TABLE의 모든 데이터가 출력이 되는 것을 전제로 조인이 되는 방식
-- RIGHT OUTER JOIN : RIGHT TABLE의 모든 데이터가 출력이 되는 것을 전제로 조인이 되는 방식
-- FULL OUTER JOIN: LEFT TABLE, RIGHT TABLE의 모든 데이터가 출력이 되는 것을 전제로 JOIN이 되는 방식 (여기서 모든 데이터가 출력이 
-- 된다는 말은 JOIN되는 TABLE에 짝궁이 없어도 출력이 된다는 이야기이다.)

SELECT A.VIDEO_NAME, A.CATEGORY, B.CAST_MEMBER, B.BIRTHDAY
  FROM NETFLIX A
  LEFT OUTER JOIN NETFLIX_CAST B
  ON A.VIDEO_NAME = B.VIDEO_NAME
WHERE B.CAST_MEMBER IS NOT NULL; -- INNER JOIN과 같은역할을 하고할수있다.

SELECT A.VIDEO_NAME, A.CATEGORY, B.CAST_MEMBER, B.BIRTHDAY
  FROM NETFLIX A, NETFLIX_CAST B
  WHERE A.VIDEO_NAME = B.VIDEO_NAME;

-- ============ 날짜함수 ============
-- DAUL : 시스템에서 제공하는 DUMMY 테이블(보통 테이블에서 데이터를 꺼내 오지 않고 임의의 상수값 같은 정해진 값만 SELECT절에 있을 때
-- 많이 사용하는 시스템 테이블이다.)
SELECT SYSDATE FROM DUAL; 

-- ADD_MONTHS (init_date, add_months)
-- 특정일자에서 월을 더한 값을 반환하는 함수
-- 매개변수
-- init_date 
--  datetime Type 또는 DATE로 변환할 수 있는 값입니다.
-- add_months 
--  초기날짜(initdate)에 추가할 개월 수를 지정합니다.
--  음수일 경우 초기 날짜(init_date)의 이전 개월로 계산됩니다.
--  0일 경우 초기날짜(init_date)의 마지막날입니다.
SELECT ADD_MONTHS(SYSDATE,3) FROM DUAL;
SELECT ADD_MONTHS(SYSDATE,-3) FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYYMMDD HH24MISS') FROM DUAL; -- HH다음에 24가온것은 시간을 24단위로 출력하겟다.
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS') FROM DUAL;

-- ============ REPLACE ============
-- 특정문자를 다른 문자로 대체하는 함수
SELECT REPLACE('코드라이언','코드','CODE') FROM DUAL; -- 코드라이언이라는 단어에서 '코드'를 'CODE'로 대체해라
SELECT REPLACE('코드라이언','코드') FROM DUAL; -- 뒤에 대체할 문자를 적어주지않으면 '코드'라는단어가 NULL이 되어 사라지게된다!
SELECT REPLACE('010-1234-5678','-') FROM DUAL;

SELECT 
'안녕하세요 
코드라이언입니다.'
FROM DUAL;

SELECT REPLACE('안녕하세요 
코드라이언입니다.',CHR(10),' ') FROM DUAL;
SELECT * FROM NETFLIX_CAST;
SELECT REPLACE(CAST_MEMBER, '이지은', '아이유') FROM NETFLIX_CAST;


-- ============ SUBSTR ============
-- 문자를 원하는 만큼 자르는 함수

-- '코드라이언'이라는 문자에서 세번째 자리부터 '라'가있는 자리부터 두글자를 가져오겠다는의미이다.
SELECT SUBSTR('코드라이언',3,2) FROM DUAL; --라이
-- 마지막인자를 생략하면 세번째자리부터 문자의 끝까지 가져오게된다.
SELECT SUBSTR('코드라이언',3) FROM DUAL; -- 라이언
SELECT SUBSTR('코드라이언',-4,3) FROM DUAL; -- 드라이
SELECT SUBSTR('코드라이언',-4) FROM DUAL; -- 드라이언

SELECT * FROM NETFLIX_CAST;
SELECT SUBSTR(CAST_MEMBER,1,1) || '*' || SUBSTR(CAST_MEMBER,3) FROM NETFLIX_CAST; -- EX)이벤트당첨자 한*희 이런거..
SELECT SUBSTR('미국 캘리포니아에 본사를 둔 우주개발 회사 오비탈 어셈블리가 2027년 세계 최초로
우주 호텔을 가동할 계획이라고 IT매체 BGR이 8일 보도했다.',1,20) || '.......' FROM DUAL;


-- ============ UPPER / LOWER 함수 ============
-- UPPER / LOWER : 문자를 대문자 / 소문자로 바꿔주는함수
SELECT UPPER('CodeLion') FROM DUAL;
SELECT LOWER('CodeLion') FROM DUAL;
SELECT * FROM MEMBER WHERE ID = UPPER('CodeLion');

-- ============ 숫자함수 ============
-- 숫자데이터를 조작하는 함수
-- ROUND : 반올림
SELECT ROUND(3.16) FROM DUAL;
SELECT ROUND(3.67) FROM DUAL;
SELECT ROUND(3.16, 1) FROM DUAL; --3.2 반올림후 소수점 첫째자리까지

-- TRUNC : 버림
SELECT TRUNC(3.16) FROM DUAL; 
SELECT TRUNC(3.67) FROM DUAL;
SELECT TRUNC(3.16,1) FROM DUAL;

-- CEIL : 올림
SELECT CEIL(3.16) FROM DUAL;
SELECT CEIL(3.67) FROM DUAL;
SELECT CEIL(-3.16) FROM DUAL;







